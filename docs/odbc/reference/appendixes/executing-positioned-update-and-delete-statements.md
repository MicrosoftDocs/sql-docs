---
description: "Executing Positioned Update and Delete Statements"
title: "Executing Positioned Update and Delete Statements | Microsoft Docs"
ms.custom: ""
ms.date: "01/19/2017"
ms.service: sql
ms.reviewer: ""
ms.subservice: connectivity
ms.topic: reference
helpviewer_keywords: 
  - "positioned deletes [ODBC]"
  - "cursor library [ODBC], positioned update or delete"
  - "positioned updates [ODBC]"
  - "ODBC cursor library [ODBC], positioned update or delete"
ms.assetid: 1d64f309-2a6e-4ad1-a6b5-e81145549c56
author: David-Engel
ms.author: v-davidengel
---
# Executing Positioned Update and Delete Statements
> [!IMPORTANT]  
>  This feature will be removed in a future version of Windows. Avoid using this feature in new development work and plan to modify applications that currently use this feature. Microsoft recommends using the driver's cursor functionality.  
  
 After an application has fetched a block of data with **SQLFetchScroll**, it can update or delete the data in the block. To execute a positioned update or delete, the application:  
  
1.  Calls **SQLSetPos** to position the cursor on the row to be updated or deleted.  
  
2.  Constructs a positioned update or delete statement with the following syntax:  
  
     **UPDATE** *table-name*  
  
     **SET** *column-identifier* **=** {*expression* &#124; **NULL**}  
  
     [**,** *column-identifier* **=** {*expression* &#124; **NULL**}]  
  
     **WHERE CURRENT OF** *cursor-name*  
  
     **DELETE FROM** *table-name* **WHERE CURRENT OF** *cursor-name*  
  
     The easiest way to construct the **SET** clause in a positioned update statement is to use parameter markers for each column to be updated and use **SQLBindParameter** to bind these to the rowset buffers for the row to be updated. In this case, the C data type of the parameter will be the same as the C data type of the rowset buffer.  
  
3.  Updates the rowset buffers for the current row if it will execute a positioned update statement. After successfully executing a positioned update statement, the cursor library copies the values from each column in the current row to its cache.  
  
    > [!CAUTION]  
    >  If the application does not correctly update the rowset buffers before executing a positioned update statement, the data in the cache will be incorrect after the statement is executed.  
  
4.  Executes the positioned update or delete statement using a different statement than the statement associated with the cursor.  
  
    > [!CAUTION]  
    >  The **WHERE** clause constructed by the cursor library to identify the current row can fail to identify any rows, identify a different row, or identify more than one row. For more information, see [Constructing Searched Statements](../../../odbc/reference/appendixes/constructing-searched-statements.md).  
  
 All positioned update and delete statements require a cursor name. To specify the cursor name, an application calls **SQLSetCursorName** before the cursor is opened. To use the cursor name generated by the driver, an application calls **SQLGetCursorName** after the cursor is opened.  
  
 After the cursor library executes a positioned update or delete statement, the status array, rowset buffers, and cache maintained by the cursor library contain the values shown in the following table.  
  
|Statement used|Value in row status array|Values in<br /><br /> rowset buffers|Values in<br /><br /> cache buffers|  
|--------------------|-------------------------------|----------------------------------|---------------------------------|  
|Positioned update|SQL_ROW_UPDATED|New values[1]|New values[1]|  
|Positioned delete|SQL_ROW_DELETED|Old values|Old values|  
  
 [1]   The application must update the values in the rowset buffers before executing the positioned update statement; after executing the positioned update statement, the cursor library copies the values in the rowset buffers to its cache.
